# 1104 Jdbc

## DB connection

1.드라이버 로딩

드라이버 디비 서버 압축해서 가지고 있는 것

연결 : jdbc 

연결하기 전에 

db도 소프트웨어 (프로그램) - 접속하려면 프로그램 정보 압축한 드라이버가 필요

- 드라이버의 정보를 이용해서 연결
- 클라이엉ㄴ트 티어의 메모리 jvm에 로딩되어야 -> 제일먼저
- 



2. 디비 서버 연결

3. PreparedStatement 객체 생성

4. 쿼리문 실행 ... 

   int executeUpdate("") -- insert/delete/update -- 0/1로 리턴 

   ResultSet executeQuery("") -- select 



for는 반복하는 횟수를 미리 알고 있을 때 

while 반복하는 횟수는 모르고 요소가 있을 때까지 반복

현재 db에 데이터 소진 될 때 까지 - while -> next로 EOE -> false -> 끝

#### Command

```
mysql> use scott;
Database changed
mysql> desc custom;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| num   | int(11)      | NO   | PRI | NULL    |       |
| name  | varchar(20)  | NO   |     | NULL    |       |
| addr  | varchar(100) | NO   |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
3 rows in set (0.01 sec)

mysql> SELECT num, name, addr FROM custom;
+-----+-------+-------+
| num | name  | addr  |
+-----+-------+-------+
| 111 | James | NY    |
| 222 | Jane  | Texas |
| 333 | Tom   | NY    |
+-----+-------+-------+
3 rows in set (0.01 sec)
```

패키지 포함한 풀네임 -> FQCN (Fully Qualified Class Name) 넣어야 함



#### DBConnectionTest.java

```java
package jdbc.test2;
/*
 * JDBC 4단계
 * 
 * 1. 드라이버 로딩
 * 2. DB 서버 연결
 * 3. PreparedStatement 객체 생성 -- 이때 쿼리문이 인자값으로 들어간다
 * 4. 값 바인딩 후 쿼리문 실행 ... 
 *    int executeUpdate("") -- insert/delete/update -- 0/1로 리턴 
 *    ResultSet executeQuery("") -- select 
 *    
 */

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class DBConnectionTest {
	DBConnectionTest() throws ClassNotFoundException, SQLException{
		//1.드라이버 로딩
		Class.forName("com.mysql.cj.jdbc.Driver"); //FQCN 
		System.out.println("1.Driver Loading...");
		
		//2. DB 서버 연결
		String url = "jdbc:mysql://127.0.0.1:3306/scott?serverTimezone=UTC&useUnicode=yes&characterEncoding=UTF-8";
		Connection conn = DriverManager.getConnection(url,"root","1234");		//Connection 객체
		System.out.println("2.DB Server Connect...");
		
		//3.PreparedStatement 객체생성
		String query = "INSERT INTO custom (num, name, addr) VALUES(?,?,?)";
		PreparedStatement ps = conn.prepareStatement(query);
		System.out.println("3.PreparedStatement Creating....");
		
		//4.?값에 대한 바인딩 -> 쿼리문 실행
		ps.setInt(1, 444);						
		ps.setString(2, "Juliet");
		ps.setString(3, "LA");
		
		System.out.println("4.row INSERT OK...("+ps.executeUpdate()+")");
			
	}

	public static void main(String[] args) throws ClassNotFoundException, SQLException {
		new DBConnectionTest();

	}//main
}//
```

```
1.Driver Loading...
2.DB Server Connect...
3.PreparedStatement Creating....
4.row INSERT OK...(1)
```

```
mysql> SELECT num, name, addr FROM custom;
+-----+--------+-------+
| num | name   | addr  |
+-----+--------+-------+
| 111 | James  | NY    |
| 222 | Jane   | Texas |
| 333 | Tom    | NY    |
| 444 | Juliet | LA    |
+-----+--------+-------+
4 rows in set (0.00 sec)
```



#### DBConnectionTest2.java

```java
package jdbc.test2;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/*
 * JDBC 4단계
 * 
 * 1. 드라이버 로딩
 * 2. DB 서버 연결
 * 3. PreparedStatement 객체생성 -- 이때 쿼리문이 인자값으로 들어간다
 * 4. 값 바인딩 후 쿼리문 실행...
 *    int executeUpdate("") -- insert/delete/update -- 0/1로 리턴
 *    ResultSet executeQuery("") -- select
 * 5. 자원을 닫아준다
 * 	  close...열은 순서 반대로 닫아준다
 *    Connection -> PreparedStatement -> ResultSet
 *    ResultSet닫고 -> PreparedStatement닫고 -> Connection 닫고
 *    안쓰는 자원이 있으면 close를 주석처리 해줘야 !! -> 오류남
 */

public class DBConnectionTest2 {
	DBConnectionTest2() throws ClassNotFoundException, SQLException{
		//선언부 미리 빼놓기
		Connection conn = null;
		PreparedStatement ps = null;
		PreparedStatement ps1 = null;
		PreparedStatement ps2 = null;
		ResultSet rs = null;
		
		try {
		Class.forName("com.mysql.cj.jdbc.Driver"); //FQCN -- 실제값
		System.out.println("1. Driver Loading....");
		
		String url ="jdbc:mysql://127.0.0.1:3306/scott?serverTimezone=UTC&useUnicode=yes&characterEncoding=UTF-8"; // -- 실제값 -> 하드코딩 x -> 고정된 값 -> 상수로 - 필드 레벨에 쓰임
		conn=DriverManager.getConnection(url, "root", "1234"); // 고정값 변수처리
		System.out.println("2. DB Server Connect....");
		
		//INSERT
//		String query = "INSERT INTO custom (num, name, addr) VALUES(?,?,?)";
//		ps=conn.prepareStatement(query);
//		ps.setInt(1, 444);
//		ps.setString(2,"Juliet");
//		ps.setString(3,"LA");
//		System.out.println(ps.executeUpdate()+" row INSERT OK..");
		
		//DELETE
//		String query1 = "DELETE FROM custom WHERE num=?";
//		ps1 = conn.prepareStatement(query1);
//		ps1.setInt(1, 444);
//		
//		System.out.println(ps1.executeUpdate()+" row DELETE OK!! ");
		
		//SELECT
		String query2 = "SELECT * FROM custom WHERE num=?";
		ps2 = conn.prepareStatement(query2);	
		ps2.setInt(1, 444);
		
		rs = ps2.executeQuery();
		if(rs.next()) //데이타가 있다면....
			System.out.println(rs.getInt("num")+","
					+rs.getString("name")+","+rs.getString("addr"));
		}finally {
			rs.close();
//			ps.close();
//			ps1.close();
			ps2.close();
			conn.close(); //try 블럭 안이라 접근 불가 -> 미리 선언 해줘야
		}
		
		
	}
	public static void main(String[] args) throws ClassNotFoundException,SQLException{	
		
		new DBConnectionTest2();
	}
}
```

```
1. Driver Loading....
2. DB Server Connect....
444,Juliet,LA
```



 * 2 step
 * 디비서버에 관련된 정보들...
 * 드라이브, 서버주소, username, password...
 * 이런 정보들을 공유하는 정보로 상수로 지정
 * -->
 * 프로그램 상에서 서버 정보들이 하드코딩 되어지지 않게 함



#### DBConnectionTest3.java

```java
package jdbc.test2;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/*
 * JDBC 4단계
 * :
 * 1. 드라이버 로딩
 * 2. DB 서버 연결
 * 3. PreparedStatement 객체생성 -- 이때 쿼리문 인자값으로 들어간다
 * 4. 값 바인딩 후 쿼리문 실행...
 *    int executeUpdate("") -- insert/delete/update --0/1
 *    ResultSet executeQuery("") -- select
 * 5. 자원을 닫아준다
 * 	  close...열은 순서 반대로 닫아준다
 *    Connection -> PreparedStatement -> ResultSet
 *    ResultSet닫고 -> PreparedStatement닫고 -> Connection 닫고
 *    안쓰는 자원이 있으면 close를 주석처리 해줘야 !! -> 오류남
 *    
 * 2 step
 * 디비서버에 관련된 정보들...
 * 드라이브, 서버주소, username, password...
 * 이런 정보들을 공유하는 정보로 상수로 지정
 * -->
 * 프로그램 상에서 서버 정보들이 하드코딩 되어지지 않게 함
 * 
 */
public class DBConnectionTest3 {
	//DRIVER_NAME, URL, USER, PASS -> 상수 지정 ... 반드시 대문자
	//실제값 -> 하드코딩 x -> 고정된 값 -> 상수로 - 필드 레벨에 쓰임
	public static final String DRIVER_NAME = "com.mysql.cj.jdbc.Driver";
	public static final String URL = "jdbc:mysql://127.0.0.1:3306/scott?serverTimezone=UTC&useUnicode=yes&characterEncoding=UTF-8";
	public static final String USER = "root";
	public static final String PASS = "1234";
	
	DBConnectionTest3() throws ClassNotFoundException, SQLException{
		//선언부 미리 빼놓기
		Connection conn = null;
		PreparedStatement ps = null;
		PreparedStatement ps1 = null;
		PreparedStatement ps2 = null;
		ResultSet rs = null;
		
		try {
		Class.forName(DRIVER_NAME); //FQCN -> 변수로
		System.out.println("1. Driver Loading....");
		
		conn=DriverManager.getConnection(URL, USER, PASS); // 고정값 변수처리
		System.out.println("2. DB Server Connect....");
		
		//INSERT
//		String query = "INSERT INTO custom (num, name, addr) VALUES(?,?,?)";
//		ps=conn.prepareStatement(query);
//		ps.setInt(1, 444);
//		ps.setString(2,"Juliet");
//		ps.setString(3,"LA");
//		System.out.println(ps.executeUpdate()+" row INSERT OK..");
	
		//DELETE
//		String query1 = "DELETE FROM custom WHERE num=?";
//		ps1 = conn.prepareStatement(query1);
//		ps1.setInt(1, 444);
//		System.out.println(ps1.executeUpdate()+" row DELETE OK!! ");
		
		//SELECT
		String query2 = "SELECT * FROM custom WHERE num=?";
		ps2 = conn.prepareStatement(query2);
		
		ps2.setInt(1, 444);
		
		rs = ps2.executeQuery();
		if(rs.next()) //데이타가 있다면....
			System.out.println(rs.getInt("num")+","
					+rs.getString("name")+","+rs.getString("addr"));
		}finally {
			rs.close();
//			ps.close();
//			ps1.close();
			ps2.close();
			conn.close(); //try 블럭 안이라 접근 불가 -> 미리 선언 해줘야
		}
		
	}
	public static void main(String[] args) throws ClassNotFoundException,SQLException{	
		
		new DBConnectionTest3();
	}
}
```

```
1. Driver Loading....
2. DB Server Connect....
444,Juliet,LA
```



서버에 연결하기 위해서는 Server Info가 필요함

클래스 안이 아닌 외부에 독립적으로 존재해야 **why?** 결합도가 낮아짐 - 재사용성을 높인다

-> 모듈화 !!

DAO: 비즈니스 로직 -> 아주 중요한 로직





### 인터페이스 활용

#### ServerInfo

```java
package config;
/*
 * 인터페이스는 상수와 추상메소드로만 구성되어져 있다
 * 이런 점을 이용해서 상수값을 담아두도록 한다
 */

public interface ServerInfo {
	//인터페이스 앞에 선언된 변수는 무조건 public static final이 붙는다 -> 필드가 없기 때문에 무조건 상수 취급
	//변수앞에 무조건 public static final이 지정된다
	String DRIVER_NAME = "com.mysql.cj.jdbc.Driver";
	String URL = "jdbc:mysql://127.0.0.1:3306/scott?serverTimezone=UTC&useUnicode=yes&characterEncoding=UTF-8";
	String USER = "root";
	String PASS = "1234";

}
```



#### DBConnectionTest.java

```java
package jdbc.test3;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import config.ServerInfo;

/* 
 * 2 step
 * 디비서버에 관련된 정보들...
 * 드라이브, 서버주소, username, password...
 * 이런 정보들을 공유하는 정보로 상수로 지정 --> 프로그램 상에서 서버 정보들이 하드코딩 되어지지 않게 함
 * 
 * 2 step에서의 문제점
 * 서버 관련 정보를 상수로 지정해서 코드에 직접 입력되는 것은 막았지만
 * Program과 서버 정보가 분리되어 있지 않다
 * 
 * Program과 서버 정보를 분리해보자
 * 상수정보를 어디에 저장해서 분리? -> 인터페이스!!!
 * 
 * config -> coonfiguration
 * 서버 정보, 기타 다른 정보들을 저장하는 모듈은 거의 대부분 coonfiguration을 뜻하는 config 패키지 하위에 모듈화 시키는 것이 관례이다
 * 
 */
public class DBConnectionTest {	
	DBConnectionTest() throws ClassNotFoundException, SQLException{
		//선언부 미리 빼놓기
		Connection conn = null;
		PreparedStatement ps = null;
		PreparedStatement ps1 = null;
		PreparedStatement ps2 = null;
		ResultSet rs = null;
		
		try {
		Class.forName(ServerInfo.DRIVER_NAME); 			//ServerInfo 인터페이스에서 가져오기
		System.out.println("1. Driver Loading....");
		
		conn=DriverManager.getConnection(ServerInfo.URL, ServerInfo.USER, ServerInfo.PASS); // 고정값 변수처리
		System.out.println("2. DB Server Connect....");
		
		//INSERT
//		String query = "INSERT INTO custom (num, name, addr) VALUES(?,?,?)";
//		ps=conn.prepareStatement(query);
//		ps.setInt(1, 444);
//		ps.setString(2,"Juliet");
//		ps.setString(3,"LA");
//		System.out.println(ps.executeUpdate()+" row INSERT OK..");
		
		
		//DELETE
//		String query1 = "DELETE FROM custom WHERE num=?";
//		ps1 = conn.prepareStatement(query1);
//		ps1.setInt(1, 444);
//		System.out.println(ps1.executeUpdate()+" row DELETE OK!! ");
		
		//SELECT
		String query2 = "SELECT * FROM custom WHERE num=?";
		ps2 = conn.prepareStatement(query2);
		
		ps2.setInt(1, 444);
		
		rs = ps2.executeQuery();
		if(rs.next()) //데이타가 있다면....
			System.out.println(rs.getInt("num")+","
					+rs.getString("name")+","+rs.getString("addr"));
		}finally {
			rs.close();
//			ps.close();
//			ps1.close();
			ps2.close();
			conn.close(); //try 블럭 안이라 접근 불가 -> 미리 선언 해줘야
		}
		
		
	}
	public static void main(String[] args) throws ClassNotFoundException,SQLException{	
		
		new DBConnectionTest();
	}
}
```





### Properties

> 외부 자원 모듈화

* 한글 안됨 - 유니코드
* 주석 : `#`
* 부모 = map -> (key, value)
  * value는 String으로 !!
* 외부 자원 모듈화
  * xml(web) / properties(spring) 을 쓴다 !
* 쿼리문도 실제값 -> 모듈화 가능 
  * 결합도 더욱 낮아짐
  * 각 전문가들 각 모듈만 담당
  * 여러개의 모듈 조합 -> 프로그램 개발

#### jdbc.properties

```properties
#### DB Server Information ####
#### xml(web) / properties(spring) ####
jdbc.mysql.driver = com.mysql.cj.jdbc.Driver
jdbc.mysql.url = jdbc:mysql://127.0.0.1:3306/scott?serverTimezone=UTC&useUnicode=yes&characterEncoding=UTF-8
jdbc.mysql.user = root
jdbc.mysql.pass = 1234


#### custom table DML query ####
jdbc.mysql.select = SELECT * FROM custom WHERE num=?
jdbc.mysql.selectAll = SELECT * FROM custom
jdbc.mysql.insert = INSERT INTO custom (num, name, addr) VALUES(?,?,?)
jdbc.mysql.delete = DELETE FROM custom WHERE num=?
jdbc.mysql.update =
```



## MVC

자바 프로그램 실행되는 순서

main 보다 static 초기화 부분이 먼저 돌아간다

