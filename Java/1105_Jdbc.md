# 1105 Jdbc

## 1. 여러가지 함수

### 1) Limit

```mysql
/*
limit
::
출력 갯수를 제한하는 기능 
시작은 0부터...0,5...상위 5개만 출력
*/
-- 문제 1. emp 테이블에서 sal가 가장 많은 사원 3명 출력 (sal ORDER BY DESC)
SELECT * FROM emp ORDER BY sal DESC;
SELECT * FROM emp ORDER BY sal DESC limit 3;
```

```
EMPNO	ENAME	JOB		MGR	HIREDATE		SAL	COMM	DEPNO
7839	KING	PRESIDENT		1981-11-17 00:00:00	5000		10
7788	SCOTT	ANALYST		7566	1987-04-19 00:00:00	3000		20
7902	FORD	ANALYST		7566	1981-12-03 00:00:00	3000		20
7566	JONES	MANAGER		7839	1981-04-02 00:00:00	2975		20
7698	BLAKE	MANAGER		7839	1981-05-01 00:00:00	2850		30
7782	CLARK	MANAGER		7839	1981-06-09 00:00:00	2450		10
7499	ALLEN	SALESMAN	7698	1981-02-20 00:00:00	1600	300	30
7844	TURNER	SALESMAN	7698	1981-09-08 00:00:00	1500	0	30
7934	MILLER	CLERK		7782	1982-01-23 00:00:00	1300		10
7521	WARD	SALESMAN	7698	1981-02-22 00:00:00	1250	500	30
7654	MARTIN	SALESMAN	7698	1981-09-28 00:00:00	1250	1400	30
7876	ADAMS	CLERK		7788	1987-05-23 00:00:00	1100		20
7900	JAMES	CLERK		7698	1981-12-03 00:00:00	950		30
7369	SMITH	CLERK		7902	1980-12-17 00:00:00	800		20
```

```
EMPNO	ENAME	JOB		MGR	HIREDATE		SAL	COMM	DEPNO
7839	KING	PRESIDENT		1981-11-17 00:00:00	5000		10
7902	FORD	ANALYST		7566	1981-12-03 00:00:00	3000		20
7788	SCOTT	ANALYST		7566	1987-04-19 00:00:00	3000		20	
```





### 2) Null

```mysql
/*
SQL에서 Null값은 제대로 다룰 수 있어야 한다
1) Null값은 아직 정해지지 않았거나 (미확정) 자격이 없을 때 사용되는 값
2) 0을 의미하는 값이 아니다
3) 값이 없는 것도 아니다. 나름 의미를 가지는 값이다. -1)에서 언급
4) 0과는 전혀 다른 값이기 때문에 비교,연산 적용이 안된다
	-> =, 1= 와 같은 연산자 사용 불가
    -> +, -, *, / 사용 불가. 대신에 ifnull()을 사용해서 값을 치환시키고 연산 적용 가능 
*/
-- 문제 2. emp 테이블에서 comm을 받지 않는 사원을 검색..이름, 업무, comm 출력
SELECT ename,job,comm FROM emp WHERE comm = null;
SELECT ename,job,comm FROM emp WHERE comm is null;
SELECT ename,job,comm FROM emp WHERE comm is not null;

SELECT sal, sal*12 + comm AnnualSalry FROM emp;
SELECT sal, sal*12 + ifnull(comm,0) AnnualSalry FROM emp;
```

```
ename	job		comm 	
SMITH	CLERK	
JONES	MANAGER	
BLAKE	MANAGER	
CLARK	MANAGER	
SCOTT	ANALYST	
KING	PRESIDENT	
ADAMS	CLERK	
JAMES	CLERK	
FORD	ANALYST	
MILLER	CLERK	
```

```
ename	job		comm 	
ALLEN	SALESMAN	300
WARD	SALESMAN	500
MARTIN	SALESMAN	1400
TURNER	SALESMAN	0
```

```
sal	AnnualSalry
800	
1600	19500
1250	15500
2975	
1250	16400
2850	
2450	
3000	
5000	
1500	18000
1100	
950	
3000	
1300	
```

```
sal	AnnualSalry
800	9600
1600	19500
1250	15500
2975	35700
1250	16400
2850	34200
2450	29400
3000	36000
5000	60000
1500	18000
1100	13200
950	11400
3000	36000
1300	15600
```



### 3) 숫자/문자/날짜 함수

```mysql
/*
숫자함수 : abs(), round(), floor(), mod(), ...

문자함수 : concat(), substr(), trim()

날짜함수 : now(), sysdate(), curdate(), year(), month()
*/

-- 문제 3. 업무가 사장인 사람과 업무가 SALESMAN인 사람의 급여 차이를 출력 
-- abs(): 절대값 함수
SELECT * FROM emp;
SELECT sal FROM emp WHERE job = 'PRESIDENT'; -- 5000
SELECT sal FROM emp WHERE job = 'SALESMAN'; -- 1600, 1250, 1250, 1500

-- SELECT DISTINCT ABS((SELECT sal FROM emp WHERE job = 'PRESIDENT') - (SELECT sal FROM emp WHERE job = 'SALESMAN')) SalaryGap FROM emp; -- 오류

SELECT DISTINCT ABS((SELECT sal FROM emp WHERE ename = 'KING') - -- 5000
(SELECT sal FROM emp WHERE ename = 'ALLEN')) SalaryGap FROM emp; -- 1600 		-> SalaryGap 3400

SELECT DISTINCT ((SELECT sal FROM emp WHERE ename = 'ALLEN') - -- 1600
(SELECT sal FROM emp WHERE ename = 'KING')) SalaryGap FROM emp; -- 5000 		-> SalaryGap -3400
SELECT DISTINCT ABS((SELECT sal FROM emp WHERE ename = 'ALLEN') - -- 1600
(SELECT sal FROM emp WHERE ename = 'KING')) SalaryGap FROM emp; -- 5000 		-> SalaryGap 3400


-- 문제 4. 사원 번호 중에서 홀수번호만 출력 
-- mod(): 나머지 함수
SELECT ename, empno, job FROM emp WHERE MOD(empno,2)=1; -- 2로 나눴을 때 나머지 1	-> empno: 7369/7499/7521/7839

-- round()
SELECT ROUND(45.923); -- 46
SELECT ROUND(45.923,0); -- 46
SELECT ROUND(45.923,2); -- 45.92 - 소수점 2번째 자리까지 출력

-- now(), sysdate(), curdate()
SELECT NOW() today; -- 2021-11-05 11:20:21
SELECT SYSDATE() today; -- 2021-11-05 11:20:22 - sysdate(): 시간까지
SELECT CURDATE() today; -- 2021-11-05 - curdate() : 날짜만

-- 문제 5. emp 테이블에서 사원들의 입사년도를 출력. 이때 사원의 이름과 함께 출력 
-- year(), month()
SELECT ename, YEAR(hiredate) YEAR, MONTH(hiredate) MONTH FROM emp;
-- substr() 
SELECT ename, SUBSTR(hiredate,1,4) YEAR, SUBSTR(hiredate,6,2) MONTH FROM emp; -- substr(hiredate,시작위치,글자길이)
```

```
ename	YEAR	MONTH
SMITH	1980	12
ALLEN	1981	2
WARD	1981	2
JONES	1981	4
MARTIN	1981	9
BLAKE	1981	5
CLARK	1981	6
SCOTT	1987	4
KING	1981	11
TURNER	1981	9
ADAMS	1987	5
JAMES	1981	12
FORD	1981	12
MILLER	1982	1
```

```
SMITH	1980	12
ALLEN	1981	02
WARD	1981	02
JONES	1981	04
MARTIN	1981	09
BLAKE	1981	05
CLARK	1981	06
SCOTT	1987	04
KING	1981	11
TURNER	1981	09
ADAMS	1987	05
JAMES	1981	12
FORD	1981	12
MILLER	1982	01
```

### 4) Like (%/_)

```mysql
/*
like와 와일드카드
::

ex) 훈련생들중 김씨로 시작하는 학생들의 명단을 검색... 
    제품중에서 삼성 2글자 포함되는 모든 제품을 검색... 
    
와일드카드 : 
	% : (0~many),  _ : (정확하게 1대1매핑) 
*/

-- 문제 6. 사원 이름중에서 S로 시작하는 사원의 이름 검색 - like
SELECT ename FROM emp WHERE ename LIKE 'S%';
-- 문제 7. 사원 이름중에서 두번째 철자가 A인 사원의 이름 검색 - like_a
SELECT ename FROM emp WHERE ename LIKE '_A%';
-- 문제 8. 사원의 이름중에서 R철자가 포함된 모든 사원을 검색
SELECT ename FROM emp WHERE ename LIKE '%R%';
```

```
SMITH
SCOTT
```

```
WARD
MARTIN
JAMES
```

```
WARD
MARTIN
CLARK
TURNER
FORD
MILLER
```



## 2. 과제 풀이

Data Pack = 값 할당/ 주입 -> setter() : 생성자

Data Unpack = 값 받아옴/반환 -> getter()

`int num`, `String name`, `String addr` 들이 pack된 객체 `Customer`를 핸들링하는 것이 더 쉬움 !!

주석 처리한 부분 -> 내 풀이... -> 변경된 부분 잘 볼 것



#### CustomerDAOImpl.java

```java
package jdbc.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;

import config.ServerInfo;
import jdbc.vo.Customer;

public class CustomerDAOImpl implements CustomerDAO {
    
	//SingleTone Pattern - dao 
	private static CustomerDAOImpl dao = new CustomerDAOImpl();
	private CustomerDAOImpl() {
		System.out.println("DAO Imple Creating...");
	}
	public static CustomerDAOImpl getInstance() {
		return dao;
	}
	
	@Override
	public Connection getConnect() throws SQLException {
		Connection conn = DriverManager.getConnection(ServerInfo.URL,ServerInfo.USER,ServerInfo.PASS);
		System.out.println("DB Server Connect...");
		return conn;
	}

	@Override
	public void closeAll(PreparedStatement ps, Connection conn) throws SQLException {
		if(ps != null) ps.close();
		if(conn != null) conn.close();
	}

	@Override
	public void closeAll(ResultSet rs, PreparedStatement ps, Connection conn) throws SQLException {
		if(rs != null) rs.close();
		closeAll(ps,conn);	
	}
	
	//Business Logic
	@Override
	public void registerCustomer(Customer vo) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;	

		try {
			conn = getConnect();		
			
			String query = "INSERT INTO custom (num, name, addr) VALUES(?,?,?)";
			ps = conn.prepareStatement(query);
			
//			int num = vo.getNum();
//			String name = vo.getName();
//			String addr = vo.getAddr();
//			
//			ps.setInt(1, num);
//			ps.setString(2, name);
//			ps.setString(3, addr);
			
			ps.setInt(1, vo.getNum());
			ps.setString(2, vo.getName());
			ps.setString(3, vo.getAddr());
			
			ps.executeUpdate();		//DB 서버의 테이블로 값이 주입됨
			System.out.println(vo.getName()+"님, 회원가입 되셨습니다.");
			
		}finally {
			closeAll(ps,conn);			
		}
	}//registerCustomer

	@Override
	public void deleteCustomer(int num) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;
		
		try {
			conn=getConnect();
			
			String query = "DELETE FROM custom WHERE num = ?";
			ps = conn.prepareStatement(query);
			
			ps.setInt(1, num);
			
			ps.executeUpdate();
			
			System.out.println(num + "번 회원님이 탈퇴하셨습니다.");
			
		}finally {
			closeAll(ps, conn);
		}
	}//deleteCustomer

	@Override
	public void updateCustomer(Customer vo) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;	

		try {
			conn = getConnect();		
			
			String query = "UPDATE custom SET name = ?, addr = ? WHERE num = ?";
			ps = conn.prepareStatement(query);
			
//			int num = vo.getNum();
//			String name = vo.getName();
//			String addr = vo.getAddr();
//			
//			ps.setString(1, name);	
//			ps.setString(2, addr);
//			ps.setInt(3, num);
			
			ps.setString(1, vo.getName());
			ps.setString(2, vo.getAddr());
			ps.setInt(3, vo.getNum());
			
			ps.executeUpdate();
			System.out.println(vo.getName()+"님의 정보가 수정되었습니다.");
			
			
		}finally {
			closeAll(ps,conn);			
		}
		
	}//updateCustomer

	@Override
	public Customer getCustomer(int num) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;
//		Customer c = new Customer();
		Customer c = null;				//생성 대신 선언
		
		try {
			conn=getConnect();
			
			String query = "SELECT * FROM custom WHERE num = ?";
			ps = conn.prepareStatement(query);
			
			ps.setInt(1, num);
			
			rs = ps.executeQuery();
			
//			while(rs.next()) {
//				c.setNum(rs.getInt("num"));
//				c.setName(rs.getString("name"));
//				c.setAddr(rs.getString("addr"));
//			}
			
			if(rs.next()) {						//while 대신 if로 - 데이터가 있다면
				c = new Customer(num,
						rs.getString("name"),
						rs.getString("addr"));	//데이터 pack해서 객체로 만들어야 함
				
			}

		}finally {
			closeAll(rs, ps, conn);
		}
		return c;
	}//getCustomer

	@Override
	public ArrayList<Customer> getAllCustomer() throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;
		ArrayList<Customer> custs = new ArrayList<Customer>();		//list는 생성까지 해야!

		try {
			conn=getConnect();
			
			String query = "SELECT * FROM custom";
			ps = conn.prepareStatement(query);
			
			rs = ps.executeQuery();
			
//			while(rs.next()) {
//				int num = rs.getInt("num");
//				String name = rs.getString("name");
//				String addr = rs.getString("addr");
//				Customer c = new Customer(num,name,addr);
//				custs.add(c);
				
			while(rs.next()) {
				custs.add(new Customer(rs.getInt("num"),
						rs.getString("name"),
						rs.getString("addr")));
			}

		}finally {
			closeAll(rs, ps, conn);
		}
		return custs;
	}//getAllCustomer
    
}//class
```



#### CustomerClientTest.java

```java
package jdbc.client;

import java.sql.SQLException;
import java.util.ArrayList;

import config.ServerInfo;
import jdbc.dao.CustomerDAOImpl;
import jdbc.vo.Customer;

public class CustomerClientTest {
	//Static 초기화
	static {
		try {
			Class.forName(ServerInfo.DRIVER_NAME);
			System.out.println("Driver Loading Success...");
		}catch(ClassNotFoundException e) {
			System.out.println("Driver Loading Fail...");
		}
	}//static

	public static void main(String[] args) throws SQLException {
		//싱글톤으로 하나 만들어놓은 객체를 받아서 사용
		CustomerDAOImpl dao = CustomerDAOImpl.getInstance();
		dao.registerCustomer(new Customer(555, "John", "Brandon"));
		dao.deleteCustomer(555);
		dao.updateCustomer(new Customer(333, "Tom", "Boston"));
		System.out.println(dao.getCustomer(111));
//		System.out.println(dao.getAllCustomer());
		ArrayList<Customer> list=dao.getAllCustomer();				
		for(Customer c : list)
			System.out.println(c);
	}//main
}//class
```

```
Driver Loading Success...
DAO Imple Creating...
DB Server Connect...
John님, 회원가입 되셨습니다.
DB Server Connect...
555번 회원님이 탈퇴하셨습니다.
DB Server Connect...
Tom님의 정보가 수정되었습니다.
DB Server Connect...
Customer [num=111, name=James, addr=NY]
DB Server Connect...
Customer [num=111, name=James, addr=NY]
Customer [num=222, name=Jane, addr=Texas]
Customer [num=333, name=Tom, addr=Boston]
Customer [num=444, name=Juliet, addr=LA]
```

