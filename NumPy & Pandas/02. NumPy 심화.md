# 02. NumPy 심화



## 1. 인덱싱 (indexing) & 슬라이싱 (slicing)

> ndarray는 python list처럼 indexing과 slicing이 가능



### 1) 기본 indexing

> 배열에서 특정 원소를 뽑아내는 것

```python
import numpy as np

arr = np.arange(10,20,1)

for temp in arr:
    print(temp)

for idx,temp in enumerate(arr): # enumerate : (반복문 사용시) 각각의 index 값 추출
    print('인덱스 : {}, 값 : {}'.format(idx,temp))
```

    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    인덱스 : 0, 값 : 10
    인덱스 : 1, 값 : 11
    인덱스 : 2, 값 : 12
    인덱스 : 3, 값 : 13
    인덱스 : 4, 값 : 14
    인덱스 : 5, 값 : 15
    인덱스 : 6, 값 : 16
    인덱스 : 7, 값 : 17
    인덱스 : 8, 값 : 18
    인덱스 : 9, 값 : 19



### 2) Slicing

> 배열에서 특정 구간을 뽑아내는 것

```python
import numpy as np

arr = np.arange(0,5,1)
print(arr) 				# [0 1 2 3 4]
print(arr[0:2]) 		# [0 1]
print(arr[0:-1]) 		# [0 1 2 3] => 맨 마지막 요소만 제외하고 슬라이싱
print(arr[1:4:2]) 		# [1 3] => 1~3까지 2칸씩 슬라이싱
```

```python
# 2차원 형태의 ndarray를 슬라이싱
import numpy as np

arr = np.array([[1,2,3,4],
                [5,6,7,8],
                [13,14,15,16]])

print(arr[1,1]) 		# 6 => 2행 1열
print(arr[1,:]) 		# [5 6 7 8] => 2행 전체
print(arr[1:3,:]) 		# [[ 5  6  7  8] => 2행~3행, 2차원 ,로 슬라이싱
                  		#  [13 14 15 16]]
print(arr[0]) 			# 행만 명시 => [1 2 3 4]
```





### 3) Boolean indexing

> ndarray중에서 boolean mask의 True 요소에 해당하는 index만 조회하는 방식

* `boolean mask`:
  * 원본 ndarray와 shape이 같고 그 요소값이 모두 `boolean`으로 구성된 ndarray
  * True, False로 구성된 `boolean mask`를 이용해 indexing 하는 방식이 `boolean indexing`

```python
import numpy as np

np.random.seed(1)
arr = np.random.randint(1,20,(10,)) 	# low,high,shape : 균등분포로 정수 표본을 추출
print(arr) 								# [6 12 13 9 10 12 6 16 1 17]

for temp in arr:
    if temp % 2 == 0:					# 조건
        print(temp, end = ' ') 			# 6 12 10 12 6 16  => 짝수
        
print(arr % 2 == 0)						# mask 생성
print(arr[arr % 2 == 0])				# boolean indexing
```

```
[ True  True False False  True  True  True  True False False]
[ 6 12 10 12  6 16]
```



### 4) Fancy indexing

> ndarray에 index 배열 (list형식) 을 전달하여 배열요소를 참조하는 방식

* `slicing`은 연속적 범위 vs. `fancy indexing`는 원하는 위치만 지정 
* `fancy indexing` : index에 `[]` => 1차원 ndarrary

```python
import numpy as np

arr = np.array([1,2,3,4,5])
print(arr[[1,3,4]]) 		# [2 4 5] => 2,4,5번째

arr = np.arange(0,12,1).reshape(3,4).copy() # 일반적으로 resize 대신 reshape
print(arr) 					# [[ 0  1  2  3]
							#  [ 4  5  6  7]
							#  [ 8  9 10 11]]
# indexing 
print(arr[2,2]) 			# 10 => 3행 3열 indexing
# slincing + indexing
print(arr[1:2,2]) 			# [6] => 행 slincing : [ 4  5  6  7], 열 indexing : [6] 
# slincing    
print(arr[1:2,1:2]) 		# [[5]] => 행 slicing : [ 4  5  6  7], 열 indexing : [[5]] 

# fancy indexing 
print(arr[[0,2],2]) 		# [2 10]
print(arr[[0,2],2:3]) 		# [[ 2]
                      		#  [10]]
```

* 다차원 ndarray는 행과 열 모두에 `fancy indexing` 적용 불가
  * numpy의 `ix_()` 함수를 이용

```python
arr = np.arange(0,12,1).reshape(3,4).copy() 
print(arr) 					# [[ 0  1  2  3]
							#  [ 4  5  6  7]
							#  [ 8  9 10 11]]
        
print(arr[[0,2],[0,2]]) 	# [[0 2]
                      		#  [8 10]] 기대 but [ 0 10] => 함수 안 문제
    
print(arr[np.ix_([0,2],[0,2])]) #[[0 2]
                              # [8 10]]   
```





## 2. ndarray 연산



### 1) 사칙연산

* ndarray 연산의 기본은 같은 위치에 있는 원소끼리 연산을 수행
  * shape이 다르면 연산 수행 불가

```python
import numpy as np

arr1 = np.array([[1,2,3],
                 [4,5,6]]) 						# 2 x 3 ndarray
arr2 = np.arange(10,16,1).reshape(2,3).copy() 	# 2 x 3 ndarray
arr3 = np.arange(10,16,1).reshape(3,2).copy() 	# 3 x 2 ndarray

print(arr1 + arr2) 		# [[11 13 15]
						#  [17 19 21]]
print(arr1 + arr3) 		# 에러

print(arr1 + arr2)  	# np.add(arr1,arr2)
print(arr1 - arr2)  	# np.subtract(arr1,arr2)
print(arr1 * arr2)  	# np.multiply(arr1,arr2)
print(arr1 / arr2)  	# np.divide(arr1,arr2)
```



### 2) 행렬곱연산

* `np.matmul()` 혹은` np.dot()`으로 수행가능
* 앞쪽 행렬의 열과 vector와 뒤쪽 행렬의 행 vector의 size가 같아야 함

```python
import numpy as np

arr1 = np.array([[1,2,3],
                 [4,5,6]]) 						# 2 x 3 ndarray
arr2 = np.arange(10,16,1).reshape(2,3).copy() 	# 2 x 3 ndarray
arr3 = np.arange(10,16,1).reshape(3,2).copy() 	# 3 x 2 ndarray

print(np.matmul(arr1,arr3)) 	# [[ 76  82]
								#  [184 199]]
print(np.dot(arr1,arr3))		# 위와 동일
```

**[참고]**

* 행렬곱이 없다면 matrix 연산은 무조건 같은 크기의 사칙연산만을 수행 가능

* 행렬곱으로 다양한 크기의 행렬을 이용하여 연속적으로 원본 데이터를 변경시키는 것이 가능 
  * 이러한 특성이 Machine Learning과 Image processing에서 자주 사용됨



### 3) Broadcasting

> 다른 shape을 가지는 ndarray도 사칙연산 가능하도록 지원

* 행렬곱 연산에 대해서는 `broadcasting`이 발생하지 않음

```python
import numpy as np

arr1 = np.array([[1,2,3],
                [4,5,6]]) 	# 2 x 3 ndarray
arr2 = np.array([7,8,9]) 	# (3, ) 1차원 ndarray
print(arr1 + arr2) 			# [[ 8 10 12]
							#  [11 13 15]] => arr2를 2차원으로 broadcasting

print(arr1 + 10) 			# [[11 12 13]  
							#  [14 15 16]] => scalar를 2차원으로 broadcasting
    
arr1 = np.array([[1,2,3],
                [4,5,6]]) 
arr2 = np.array([7,8]) 
print(arr1 + arr2) 			# 에러 => 배수가 아니므로 broadcasting 불가
```



### 4) 비교연산

> 사칙연산과 마찬가지로 같은 index의 요소들끼리 동작

* 두 개의 배열과 같은 크기의 배열에 True/False의 값 반환
  * `boolean mask`
* `array_equal()`:  두 개의 배열 전체를 비교해주는 함수


```python
import numpy as np

np.random.seed(4) 						# seed : 난수 동일하게
arr1 = np.random.randint(0,10,(2,3))
arr2 = np.random.randint(0,10,(2,3))

print(arr1)
print(arr2)

print(arr1 == arr2) 					# 논리 연산의 결과 => boolean
print(arr1 > arr2) 

arr1 = np.arange(10)
arr2 = np.arange(10)
print(np.array_equal(arr1,arr2)) 		# array_equal():  두 배열 전체 비교
```

    [[7 5 1]
     [8 7 8]]
    [[2 9 7]
     [7 7 9]]
     
    [[False False False]
     [False  True False]]
    [[ True False False]
     [ True False False]]
     
    True





## 3. 전치행렬 (transpose) 

> 원본행렬의 행은 열로, 열은 행으로 바꾼 행렬 (matrix)

```python
import numpy as np

arr = np.array([[1,2,3],
               [4,5,6]]) 	# 2 x 3 ndarray
print(arr.T) 				# [[1 4]
							#  [2 5]
							#  [3 6]]
```

* `.T`를 이용해서 표현
  * `.T` 속성을 이용하면 전치행렬을 구할 수 있음 (View)
* 1차원 vector는 전치행렬 x



**[참고]**

- 0차원 : 하나의 숫자 => scalar(스칼라) 
- 1차원 : 열로 구성 => vector(벡터) 
- 2차원 : 행렬로 구성 => matrix(매트릭스) 
- 3차원 이상 => array



## 4. 반복자 (iterator)

> ndarray의 index를 지칭 및 지시 

* 명시적 인덱싱, 슬라이싱 이외에 행렬 모든 원소에 접근할 경우 `iterator` 사용
  * `next()`메서드를 통해 데이터 값을 처음부터 끝까지 순차적으로 읽어들이는 방법을 제공
  * `numpy.nditer(ndarray, flags=[' '])` 방식으로 사용
    * `c_index` : 1차원 /  `multi_index` : 2차원

* 반복문: `for`  vs. `while` 
  * `for` :   반복하는 횟수를 알고 있을 때
    * numpy ndarray를 반복처리할 때 주로 사용
  * `while` : 차원에 상관없이 조건에 따라서 반복할 때 


```python
import numpy as np

# 1차원 배열
arr = np.array([1,2,3,4,5])

# for문을 이용한 반복처리
for tmp in arr:
    print(tmp,end = ' ')
print()										# 1 2 3 4 5 

# while문과 iterator를 이용해서 반복처리
it = np.nditer(arr,flags = ['c_index']) 	# c_index : c 언어의 index 스타일
while not it.finished: 						# 반복문 
    idx = it.index 							# 0 : c 스타일의 index는 0 부터 시작
    print(arr[idx],end = ' ') 				# indexing
    it.iternext() 							# iterator 옮기기
											# 1 2 3 4 5 

# 2차원 배열
arr = np.array([[1,2,3],
               [4,5,6]])

# for로 반복처리
for tmp1 in range(arr.shape[0]): 			# arr.shape = (2,3)이면 arr.shape[0] = 2
    for tmp2 in range(arr.shape[1]):
        print(arr[tmp1,tmp2],end = ' ') 	# tmp1: 행, tmp2: 열
print()										# 1 2 3 4 5 6

# while문과 iterator로 반복처리
it = np.nditer(arr,flags = ['multi_index'])
while not it.finished:     
    idx = it.multi_index 					# (0,0)
    print(arr[idx], end = ' ')  			# fancy indexing => 동일 코드로 반복작업 가능
    it.iternext()
											# 1 2 3 4 5 6
```





## 5. 축 (axis) 기반 함수

### 1) 집계 & 수학함수

* 집계함수 : 합, 평균, 표준편차, 분산
  * 계산 시 로직도 사용 가능 but 집계함수의 속도가 빠름
* 수학함수 : 최대, 최소, 제곱근, 제곱값, 로그값

```python
import numpy as np

arr = np.arange(1,7,1).reshape(2,3).copy()
print(arr)				# [[1 2 3]
						#  [4 5 6]]

print(np.sum(arr)) 		# 21 => numpy의 sum 기능
print(arr.sum()) 		# 21 => array 데이터의 합

print(np.mean(arr)) 	# 3.5 => 평균

print(np.max(arr)) 		# 6 => 최대
print(np.min(arr)) 		# 1 => 최소

print(np.argmax(arr)) 	# 5 => 최대값의 index 리턴
print(np.argmin(arr)) 	# 0 => 최소값의 index 리턴

print(np.std(arr)) 		# 표준편차
print(np.sqrt(arr)) 	# 제곱근
```



> Q. ndarray arr안에 10보다 큰 수가 몇 개?

* 가장 쉽고 빠른 방법은  `boolean indexing`을 이용하는 방법 !!

```python
arr = np.array([[1,2,3,4],
               [5,6,7,8],
               [9,10,11,12],
               [13,14,15,16]])

print((arr > 10).sum()) # arr > 10 : boolean mask
						# 6 => 조건을 만족하는 개수 (False = 0, True = 1로 계산)
```



* Numpy의 모든 집계함수는 기본적으로 `axis`를 기준으로 계산

  * 만약 `axis`를 지정하지 않으면 None으로 설정되고 대상범위가 배열의 전체로 지정

  * 1차원에서` axis`는 0만 사용 가능 => 0: 열방향

    2차원에서 `axis`는 0과 1 사용 가능 => 0: 행방향, 1: 열방향

    3차원에서 `axis`는 0, 1, 2 사용 가능 => 0: 면, 1: 행방향, 2: 열방향

```python
import numpy as np

# 1차원 ndarray
arr = np.array([1,2,3,4,5]) 	
print(np.sum(arr)) 				# 15
print(arr.sum()) 				# 15
print(arr.sum(axis = 0)) 		# 15 => 1차원에서 axis=0은 열방향 (가로 합) 
print(arr.sum(axis = 1)) 		# error => 1차원에서 axis=1은 존재 x
```

```python
import numpy as np

# 2차원 ndarray
arr = np.array([[1,2,3],
               [4,5,6],
               [7,8,9],
               [10,11,12]])
print(arr.shape) 				# (4, 3) => 4행 3열

# axis 설정 x
print(arr.sum()) 				# 78 => axis=None이므로 전체 합

# axis 설정
print(arr.sum(axis = 0)) 		# [22 26 30] => 2차원에서 axis=0은 행방향 (세로 합) 
print(arr.sum(0)) 				# 숫자만 적어도 ok

print(arr.argmax(axis = 0)) 	# [3 3 3] => 10,11,12 => 행방향 (세로 max의 index) 
print(arr.argmax(axis = 1)) 	# [2 2 2 2] => 3,6,9,12 => 열방향 (가로 max의 index) 
```

```python
np.random.seed(1)
arr = np.random.randint(0,12,(4,3))
print(arr)						# [[ 5 11  8]
         						#  [ 9 11  5]
        						#  [ 0  0  1]
         						#  [ 7  6  9]]
            
print(arr.argmax(axis = 0)) 	# [1 0 3] => 9,11,9 => 행방향 (세로 max의 index) 
print(arr.argmax(axis = 1)) 	# [1 1 2 2] => 11,11,1,9 => 열방향 (가로 max의 index)
```



### 2) 정렬: sort()

* `sort()` : `axis`를 기준으로 정렬
  * `axis`를 지정하지 않으면 -1 => 마지막 `axis` 의미

* `np.sort()` : 원본 배열은 변화없음, 정렬된 결과 배열을 return
* `arr.sort()` : 원본 배열을 정렬, None return

```python
import numpy as np
arr = np.arange(10)
np.random.shuffle(arr)
print(arr)					# [6 4 7 0 1 2 3 5 9 8]

print(np.sort(arr)) 		# [0 1 2 3 4 5 6 7 8 9]
print(arr) 					# [6 4 7 0 1 2 3 5 9 8] => 원본 변화 x

print(arr.sort()) 			# None => return 없음
print(arr) 					# [0 1 2 3 4 5 6 7 8 9] => 원본 정렬

							# 특수한 슬라이싱 이용 역순 정렬 가능
print(np.sort(arr)[::-1]) 	# [9 8 7 6 5 4 3 2 1 0]
```



### 3) 연결: concatenate()

* `concatenate()` : `axis`를 기준으로 행과 열을 추가

```python
import numpy as np

arr = np.array([[1,2,3],
               [4,5,6]]) 		# (2,3)

new_row = np.array([7,8,9]) 	# (3,)

result = np.concatenate((arr,new_row.reshape(1,3)),axis = 0) # 가로(행)방향 연결
print(result)					# [[1 2 3]
              					#  [4 5 6] => arr
              					#  [7 8 9]] => new_row
        
new_col = np.array([7,8,9,10]) 

result = np.concatenate((arr,new_col.reshape(2,2)),axis = 1) # 세로(열)방향 연결
print(result) 					# [[ 1  2  3  7  8]
              					#  [ 4  5  6  9 10]]
```



### 4) 삭제: delete()

* `delete()`  : `axis`를 기준으로 행과 열을 삭제
  * `axis`를 지정하지 않으면 1차배열로 변환 후 삭제
  * 원본배열을 변경하지 않고 새로운 배열 return

```python
import numpy as np

arr = np.array([[1,2,3],
               [4,5,6]]) 			# (2,3) 행렬

result = np.delete(arr,1) 			# 1차 배열로 변환한 후 2 (index = 1) 삭제
print(result) 						# [1 3 4 5 6]

result = np.delete(arr,1,axis = 0)  # 2행 삭제
print(result) 						# [[1 2 3]]

result = np.delete(arr,1,axis = 1) 	# 2열 삭제
print(result) 						# [[1 3]
              						#  [4 6]]
```

