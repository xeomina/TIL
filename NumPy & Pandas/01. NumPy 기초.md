# 01. NumPy 기초



## 1. NumPy 개요

> 과학 계산을 위해 사용되는 파이썬 데이터분석 라이브러리

- *Numerical Python*을 의미
- 벡터(vector), 행렬(matrix) 연산에 있어서 상당한 편리성을 제공
- *Pandas*와 *matplotlib*의 기반이 되는 module
- numpy의 기본적인 자료구조:
  - `ndarray` : n차원의 배열 (n-dimensional array)



> numpy module 설치

* anaconda prompt : `conda install numpy` or `!pip install numpy`

* *jupyter notebook* 실행: `import numpy as np`



**[참고]**

* 모듈 (module) : 각종 변수, 함수, 클래스를 담고 있는 .py 파일

* 패키지 (package) : 특정 기능과 관련된 여러 모듈의 묶음. 

* 라이브러리 (library) : 모듈과 패키지, 내장 함수의 묶음



 

## 2. ndarray 특징

* numpy ndarray는 차원의 개념

```
0차원 : 하나의 숫자 => scalar(스칼라) 	ex. 5
1차원 : 열로 구성 => vector(벡터) 	ex. [1 3 5 7 9]
2차원 : 행렬로 구성 => matrix(매트릭스) 	ex. [[1 2 3]
                                          	[4 5 6]]
3차원 이상 => array
```



```python
import numpy as np

my_array = np.array([1,2,3,4])          # list를 ndarray로 변환
print(my_array)        					# [1 2 3 4] => 공백으로 구분
print(type(my_array))  					# <class 'numpy.ndarray'>

# .dtype : data type 확인
my_array = np.array([1,2,3,4]) 
print(my_array.dtype)  					# int32 : 32bit 정수형 
print(type(my_array[0])) 				# <class 'numpy.int32'>

my_array = np.array([1,2,True,'Hello'])   
print(my_array.dtype) 					# <U32 => 32bit형 유니코드 (문자)
print(type(my_array[0])) 				# <class 'numpy.str_'>
print(type(my_array[3])) 				# <class 'numpy.str_'>
										# int32를 str_로 => 같은 데이터 타입

my_array = np.array([[1,2,3],[4,5,6]])
print(my_array) 						# [[1 2 3]
                						#  [4 5 6]]
print(my_array[1,1]) 					# 5 => 1행 1열 (2차원)
```

* 공백으로 요소를 구분
* 모든 요소가 같은 데이터 타입을 가져야 함
* 차원의 개념이 존재 (행과 열)



> python의 list와 비교

```python
my_list = [1,2,3,4]  			    # literal (프로그램적 기호를 이용해서 표현)
print(my_list)       			    # [1, 2, 3, 4] => , 로 구분
print(type(my_list))  		    	# <class 'list'>

my_list = [1,3.14,True,'Hello']   	
print(type(my_list[0])) 		    # <class 'int'>
print(type(my_list[3])) 		    # <class 'str'> => 데이터 타입 다름

my_list = [[1,2,3],[4,5,6]]
print(my_list) 						# [[1,2,3],[4,5,6]] => 중첩 리스트 (1차원)
```

* `,` 로 요소를 구분
* 모든 요소가 같은 데이터 타입을 가지지 않아도 됨
* 차원의 개념이 없음 (중첩 리스트)



## 3. ndarray 속성

### 1) 차원 : ndim, shape

* `.ndim` : 차원의 수를 나타냄
* `.shape` : 차원과 요소의 개수를 tuple 형태로 나타냄 (배열의 형태)

```python
import numpy as np

# 1차원
my_list = [1,2,3,4]
arr = np.array(my_list)
print(arr.ndim)  			# 1 => 1차원
print(arr.shape) 			# (4,) => 4개의 요소

# 2차원
my_list = [[1,2,3],[4,5,6]]
arr = np.array(my_list)
print(arr.ndim) 			# 2
print(arr.shape) 			# (2,3) => 2행 3열

# 3차원
my_list = [[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]]
arr = np.array(my_list)
print(arr.ndim) 			# 3
print(arr.shape) 			# (2,2,3) => 2면 2행 3열
print(arr)					# [[[ 1  2  3]
							#   [ 4  5  6]]

							#  [[ 7  8  9]
							#   [10 11 12]]]
```





### 2) 크기 : size

* `len()` : 차원에 상관 없이 1차원의 요소의 개수를 나타냄 (python 함수)
* `.size `: 모든 요소의 개수를 나타냄

```python
import numpy as np

my_list = [1,2,3,4]
arr = np.array(my_list)
print(len(arr)) 			# 4 => len(arr): python 함수
print(arr.size) 			# 4 => arr.size: numpy 속성


my_list = [[1,2,3],[4,5,6]]
arr = np.array(my_list)
print(len(arr)) 			# 2 => 1차원 2개의 요소 
print(arr.size)  			# 6 => 총 6개의 요소
```



### 3) 데이터 타입 : dtype 

* `.dtype` : 요소의 데이터 타입 나타냄
  * ndarray 생성시 데이터 타입 지정 가능
  * 명시적으로 타입을 지정하지 않으면 적절한 타입을 알아서 지정

```python
my_array = np.array([[1,2,3],[4,5,6]]) 
print(my_array.dtype) 					 # int32

# dtype으로 data type 지정
my_array = np.array([[1,2,3],[4,5,6]],dtype=np.float64) 
print(my_array.dtype) 					 # float64
print(my_array) 						 # [[1. 2. 3.]
                						 #  [4. 5. 6.]]
```



> `astype()` : data type을 변경해주는 함수

```python
import numpy as np

arr = np.array([1.2,2.3,3.5,4.1,5.7])
print(arr) 								# [1.2 2.3 3.5 4.1 5.7]
print(arr.dtype)						# float64

arr = arr.astype(np.int32)  			# 32bit 정수
print(arr) 								# [1 2 3 4 5]
print(arr.dtype)						# int32
```





## 4. ndarray 생성 함수

```txt
1. np.array()
2. np.ones(), np.zeros(). np.full(), np.empty()
3. np.arange()
4. np.random.normal(), np.random.rand(), np.random.randn()
   np.random.random(), np.random.randint()
```



### 1) np.array()

* 파이썬의 list, tuple 등의 시퀀스 자료형을 ndarray로 변환
* 인자로  list, tuple => 그냥 숫자 나열은 불가

```python
import numpy as np

arr = np.array((0.1,0.2,0.3))   
	# np.array([0.1,0.2,0.3])
    # np.array(0.1,0.2,0.3)				# 오류!
    
print(arr) 								# [0.1 0.2 0.3]

arr = np.array(((1,2,3),(4,5,6)))
	# np.array([(1,2,3),(4,5,6)]) 
	# np.array([[1,2,3],[4,5,6]])
    
print(arr)  							# [[1 2 3]
  										#  [4 5 6]] 
```



### 2). np.zeros(), np.ones(), np.empty(), np.full()

- `np.zeros()` : 특정 형태의 ndarray를 생성하여 모든 값 0으로 초기화
- `np.ones()` : 특정 형태의 ndarray를 생성하여 모든 값 1로 초기화
- `np.empty()` : 값을 초기화하지 않고 특정 형태의 ndarray 생성
  - 메모리의 상태에 따라 초기값 임의로 결정
- `np.full()` : 특정 형태의 ndarray를 생성하여 원하는 값으로 초기화

```python
import numpy as np

a = np.zeros((3,4))  					   # 0. => 기본 데이터 타입 float64 
print(a)             

b = np.zeros((3,4), dtype = np.int32) 	   # 0 => 데이터 타입 int32로 지정하여 생성
print(b)

c = np.ones((3,4)) 	 
print(c)

d = np.empty((3,4))   
print(d)

e = np.full((3,4), 7)  					    # 7 => 기본 데이터 타입 int32 
print(e)

f = np.full((3,4), 7, dtype = np.float64)   # 7. => 데이터 타입 float64로 지정하여 생성
print(f)
```

```python
[[0. 0. 0. 0.]
 [0. 0. 0. 0.]
 [0. 0. 0. 0.]]
[[0 0 0 0]
 [0 0 0 0]
 [0 0 0 0]]
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
[[7 7 7 7]
 [7 7 7 7]
 [7 7 7 7]]
[[7. 7. 7. 7.]
 [7. 7. 7. 7.]
 [7. 7. 7. 7.]]
```



### 2) np.arange()

* `np.arange()` : 주어진 범위 내에서 지정한 간격으로  연속적인 원소를 가진 배열을 생성
* np.arange (시작,끝,간격) => 시작은 inclusive, 끝은 exclusive 
  * python의 `range()`와 유사

```python
# python range()
arr = range(0,10,2)		  
print(list(arr)) 		    # [0, 2, 4, 6, 8]

# numpy np.arange()
arr = np.arange(0,10,2)
print(arr) 				    # [0 2 4 6 8]
```

```python
# reshape()으로 shape 변경
arr = np.arange(0,10,1)
print(arr)					# [0 1 2 3 4 5 6 7 8 9]
print(arr.reshape((2,5)))   # [[0 1 2 3 4]
							#  [5 6 7 8 9]]
```



### 3) random 기반 함수

- `np.random.normal()` : 
  - 정규분포 확률밀도에서 실수 표본추출 
  - `np.random.normal (평균,표준편차,shape)
- `np.random.rand()` : 
  - [0,1)의 균등분포 확률밀도에서 실수 표본추출 
  - np.random.rand (d0,d1,d2,...)
- `np.random.randn()` : 
  - 표준정규분포(평균:0, 표준편차:1) 확률밀도에서 실수 표본추출 
  - np.random.randn (d0,d1,d2,...)
- `np.random.randint()` :  
  - 균등분포 확률밀도에서 주어진 범위 내의 정수 표본추출 
  - np.random.randint (low,high,shape)
- `np.random.random()` : 
  - [0,1)의 균등분포 확률밀도에서 실수 표본추출
  - np.random.random (shape)



> 간단한 그래프 모듈인 *matplotlib*을 이용해서 데이터 분포 살펴보기

```python
import matplotlib.pyplot as plt 
import numpy as np

# 1. random.normal() : 정규분포에서 실수 형태의 난수를 추출
arr = np.random.normal(50,2,(10000,))
print(arr)
plt.hist(arr,bins=100)
plt.show()


# 2. random.rand() : 균등분포에서 0이상 1미만의 실수 형태의 난수를 추출  
arr = np.random.rand(10000)
print(arr)
plt.hist(arr,bins=100)
plt.show()


# 3. random.randn() : 준 정규분포에서 실수 형태의 난수를 추출
arr = np.random.randn(10000)
print(arr)
plt.hist(arr,bins=100)
plt.show()


# 4. random.randint()` : 균등분포에서 정수 형태의 난수를 추출
arr = np.random.randint(10,100,(10000,))
print(arr)
plt.hist(arr,bins=10)
plt.show()


# 5.random.random()` : 균등분포에서 0이상 1미만의 실수 형태의 난수를 추출
#     np.random.rand(10000)      # rand와 random은 사용방법이 다름
arr = np.random.random((10000,))
print(arr)
plt.hist(arr,bins=100)
plt.show()
```

    [49.94595058 48.64158308 51.46178838 ... 47.64081072 47.72667783
     49.84817711]



![png](C:\Users\mina\TIL\NumPy & Pandas\md-images/output_0_1.png)


    [0.5168374  0.81732299 0.28876534 ... 0.75604846 0.28745987 0.19031607]



![png](C:\Users\mina\TIL\NumPy & Pandas\md-images/output_0_3.png)


    [ 1.09719149  0.17561518 -0.20543013 ... -0.92505824 -1.06831354
     -0.15987919]



![png](C:\Users\mina\TIL\NumPy & Pandas\md-images/output_0_5.png)


    [94 67 96 ... 14 79 63]



![png](C:\Users\mina\TIL\NumPy & Pandas\md-images/output_0_7.png)


    [0.86696796 0.82966323 0.80032142 ... 0.0449949  0.5701182  0.60035646]



![png](C:\Users\mina\TIL\NumPy & Pandas\md-images/output_0_9.png)





**[참고] random 관련 함수**

1. `np.random.seed()`: 
   * 난수의 시작점을 설정하는 함수
     * 실행할 때 마다 같은 난수가 추출 (난수의 재현성 확보)
   * 정수만 사용되고 음수는 사용할 수 없음


```python
import numpy as np

np.random.seed(3) 
arr = np.random.randint(0,100,(10,))	
print(arr)			# [24  3 56 72  0 21 19 74 41 10] 
```

2. `np.random.shuffle()`:
   *  이미 만들어진 데이터의 순서를 random하게 변경해주는 함수

```python
arr = np.arange(10)
print(arr)			# [0 1 2 3 4 5 6 7 8 9]
np.random.shuffle(arr)
print(arr) 			# [6 7 9 2 4 5 0 3 1 8]
```





## 5. ndarray shape 조절 함수

> shape 직접 변경 => 비권장

```python
import numpy as np

my_list = [1,2,3,4]
arr = np.array(my_list)
print(arr.shape) 		 # (4,)

arr.shape = (2,2)
print(arr) 				 # [[1 2]
           			  	 #  [3 4]]
print(arr.shape)		 # (2,2)

# arr.shape = (2,3) 	# 요소의 갯수가 다르기 때문에 에러

arr.shape = (4,1,1)
print(arr) 				# [[[1]]

           				#  [[2]]

           				#  [[3]]

           				#  [[4]]]
```

* 함수를 사용해 shape 조절하는 것이 바람직



### 1) reshape()

* `reshape()` : 새로운 ndarray를 만들지 않고 View를 생성
  * 배열의 데이터는 공유하지만 shape이 다른 View를 생성 
  * 데이터가 공유되기 때문에 배열을 변경하면 다른 View에도 영향을 미침

```python
import numpy as np

arr = np.arange(12) 	 
arr1 = arr.reshape(3,4)   

# ndarray 요소 변경하기        
arr1[0,2] = 200 		  # 2를 200으로 변경
print(arr1[0,2]) 		  # 200
print(arr[2]) 			  # 200 => 원본도 변경됨     
```

* `copy()`: 내용을 복사해서 새로운 ndarray를 생성
  * 원본에 영향 x

```python
arr = np.arange(12)  
arr1 = arr.reshape(3,4).copy()  
arr1[0,0] = 100 		  # 0을 100으로 변경
print(arr1[0,0]) 		  # 200
print(arr[0]) 			  # 0 => 원본은 변화 x
```

* `reshape( , ,-1)` : 차원 하나를 -1로 설정할 경우
  *  배열의 전체 원소 개수와 확정된 차원 크기로 부터 남은 차원의 크기를 추론하여 배열을 생성

```python
arr = np.arange(12) 	    
arr1 = arr.reshape(2,3,-1)  # -1: 추론하여 재배열
print(arr1)					# [[[ 0  1]

           					#  [ 2  3]

           					#  [ 4  5]]

           					#  [[ 6  7]
            				#  [ 8  9]
          					#  [10 11]]]
```



### 2) ravel()

* `ravel()` : ndarray의 모든 요소를 포함하는 1차원의 ndarray로 변경
  *  View를 리턴

```python
arr = np.array([[1,2,3,], [4,5,6]]) 
print(arr) 			# [[1 2 3] 
					# [4 5 6]]

arr1 = arr.ravel()  # View
print(arr1) 		# [1 2 3 4 5 6]
```





### 3) resize()

* `resize()`: 
  * shape을 변경하는 과정에서 배열 요소 수가 변할 수 있음
  * `reshape()`는 배열 요소 수를 변경하지 못함

```python
# 원본이 2행3열인데 3행 4열로 변경
arr = np.array([[1,2,3,], [4,5,6]])
print(arr) 

arr.resize(3,4)  # 요소수가 늘어나면 0으로 세팅 
print(arr) 
arr.resize(2,2)  # 요소수가 줄면 기존 데이터 삭제
print(arr)
```

```python
[[1 2 3]
 [4 5 6]]
[[1 2 3 4]
 [5 6 0 0]
 [0 0 0 0]]
[[1 2]
 [3 4]]
```



* `resize()`를 호출하는 방식에 따라서 원본 변경 혹은 결과 배열이 리턴
  * arr.resize(shape): 결과를 리턴하지 않고 원본 자체를 바꿈
  * np.resize(arr, (shape)): 원본은 불변, 새로운 배열 생성 (View 생성이 아님)

```python
arr = np.array([[1,2,3,], [4,5,6]])
print(arr)

arr1 = np.resize(arr,(1,6))  
print(arr1)					 # 새로운 배열 생성
print(arr) 					 # 원본 불변

arr1 = arr.resize(1,6)   	
print(arr1) 				 # return 없음
print(arr)					 # 원본 변경
```

    [[1 2 3]
     [4 5 6]]
     
    [[1 2 3 4 5 6]]
    [[1 2 3]
     [4 5 6]]
     
    None
    [[1 2 3 4 5 6]]

